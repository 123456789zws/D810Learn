
### d810组件

+ microcode 仿真执行

+ MopTracker 向后变量跟踪

+ Microcode control flow patching  微码控制流修补
首先获取所有的ollvm 分发器对应的分支，然后计算出对应分支的所有块，分支的计算从分发器修改的位置开始计算，不是从块起始位置计算。
在这些分支块中进行计算，找到块有两个以上前驱，并且这个两个前驱到这个块本身，会有两个分发值，这说明这个块需要复制，不是有两个以上前驱的一定需要复制，经常有的块
有好几个前驱，但是块本身会使用常量对分发器赋值，这种是不需要赋值的，因为分支的起始位置起始就是块本身。

### fla对抗工作流程

+ 识别分发器
+ 寻找的分发分支以及对应的 常量值
+ 分析常量值和对应的先后执行顺序
+ 修复代码块


### bcf 对抗

通过真实执行或者类似真实执行的分析可以识别出那些是虚假块，可能会遇到不透明谓词的分支跳转，或者花指令，混淆

### 混淆，指令替换
主要是不透明谓词，混淆，需要人工，或者半人工，配合一下自动化优化工具进行反向指令替换